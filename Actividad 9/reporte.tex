% https://es.overleaf.com/latex/templates/project-report/jpzczmpsdzwm

%%% Preamble
\documentclass[paper=leter, fontsize=11pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[spanish,mexico]{babel}
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{lmodern}
\usepackage{hyperref}       % hyperlinks
\usepackage{lipsum}
\usepackage[square,numbers]{natbib}

\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}

\usepackage{tikz}

\usepackage{caption}
\usepackage{subcaption}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Código}

\graphicspath{ {.} }

\selectlanguage{spanish}
\usepackage[spanish,onelanguage]{algorithm2e}


%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}


%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule

\title{
		%\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{Posgrado de Ingeniería de Sistemas} \\ [25pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge Árboles biselados \\
		\horrule{2pt} \\[0.5cm]
}
\author{
		\normalfont 								\normalsize
        Alberto Benavides\\[-3pt]		\normalsize
        \today
}
\date{}


%%% Begin document
\begin{document}
\maketitle

Un \textit{montículo de fibonacci} es una estructura de datos en la que se tienen conjuntos de árboles en los que se distingue como mínimo al nodo que tiene el menor valor de las raíces de los árboles. En estas estructuras, cada nodo cuenta con una serie de características:
\begin{itemize}
    \item un puntero al nodo padre,
    \item un puntero a alguno de sus hijos,
    \item un puntero a la izquierda,
    \item un puntero a la derecha,
    \item el número de nodos hijos (también llamado \textit{grado}), y
    \item una marca booleana.
\end{itemize}

Estos montículos tienen una cantidad $n$ de nodos distribuidos en $t$ árboles de los cuales, el que tiene su raíz con el menor valor tiene un puntero $\textit{min}$ apuntando a dicha raíz. Además, se debe cumplir de que no puede haber dos árboles con el mismo $\text{grado}$ o número de hijos. Para evitar esta situación, se comparan los nodos del mismo nivel por pares de nodos, convirtiendo al nodo de mayor valor y misma cantidad de hijos en un hijo del nodo de menor valor \cite{fibonacci_heap, aa}.

En comparación con otras estructuras de datos, este algoritmo tiene una complejidad computacional que en el peor de los casos y sólo para las operaciones de eliminación y eliminación del valor menor es de $\mathcal{O}(\log n)$, mientras que para el resto de operaciones es $\mathcal{O}(1)$, tal como se muestra en el cuadro \ref{complejidad} \cite{fibonacci_heap}.

\begin{table}[]
    \centering
    \caption{Complejidad computacional de los montículos de Fibonacci.}
    \label{complejidad}
    \begin{tabular}{ll}
    \textbf{Operación}    & \textbf{Tiempo}         \\ \hline
    Inserción       & $\mathcal{O}(1)$                 \\
    Eliminación       & $\mathcal{O}(\log n)$            \\
    Encontrar el mínimo     & $\mathcal{O}(1)$                 \\
    Extraer el mínimo  & $\mathcal{O}(\log n)$            \\
    Disminuir llave & $\mathcal{O}(1)$                 \\
    Unión        & $\mathcal{O}(1)$                       
    \end{tabular}
    \end{table}

Estas peculiaridades permiten que los montículos sean preferidos para implementaciones en filas prioritarias o en algoritmos de teoría de grafos como el Dijstra's en el que se busca el camino más corto de un vértice inicial al resto de los vértices\footnote{En \url{https://kbaile03.github.io/projects/fibo_dijk/fibo_dijk.html} hay una implementación visual de esto} \cite{binary_heap}.

Finalmente, se muestra la implementación en \texttt{javascript} de un montículo de fibonacci en \url{https://jbenavidesv87.github.io/algoritmos/heapFibonacci.html} capaz de insertar nodos y eliminar el mínimo. La visualización falla. Se puede revisar la consola

\bibliographystyle{plainnat}
\bibliography{Biblio}

\end{document}